# -*- coding: utf-8 -*-
"""Crypto ITKoin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1apRntoEFNWN1Z64acX__i6QArBVWEO8L
"""

#!pip install pycryptodome

# Imports
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Signature import pkcs1_15
from base64 import b64encode, b64decode
from pprint import pprint
import json

# ITKoin class
class ITKoin:

    # Constructor of the ITKoin class
    #   fileName: where to save / load the keys
    #   [passphrase]: The passphrase that encrypts the key
    #   [generateKey]: generate and save (False) or load the keys (True) 
    def __init__ (self,fileName,passphrase=None,generateKey=False):
        self.pending_transactions = []
        self.unspent_transactions = []
        self.sender_inputs = []
        self.chain = []
        
        if generateKey: # In case of need, generate new keys
          self.generate_rsa_key(fileName,passphrase)
        self.load_key(fileName,passphrase) # Load from file to memory #verrySecure/s

    # This static method generates RSA2048 keys, and save them to files.
    #   fileName: the name of the files to store the keys
    #   [passphrase]: The passphrase that encrypts the privatekey
    @staticmethod
    def generate_rsa_key(fileName,passphrase=None):
        # Generate keys
        key = RSA.generate(2048) # WARNING: hardcode!

        # Export the private key to file, optionaly encrypts with passphrase
        priKey = key.export_key(passphrase=passphrase)
        f = open(fileName+"pri.pem", "wb")
        f.write(priKey)
        f.close()

        # Export the public key to file
        pubKey = key.publickey().export_key()
        f = open(fileName+"pub.pem", "wb")
        f.write(pubKey)
        f.close()
        return

    # Load the private key and the corresponding public key, from a file.
    #   fileName: the name of the files where the stored keys is
    #   [passphrase]: The passphrase that decrypts the privatekey
    def load_key(self, fileName, passphrase=None):
        self.priKeyRSA = RSA.import_key(open(fileName+"pri.pem").read(),passphrase=passphrase)
        self.pubKeyRSA = self.priKeyRSA.publickey()
        return

    # Load the public key from a file.
    #   fileName: the name of the files where the stored keys is
    #   return: the publick key
    def load_public_key(self, fileName):
        return RSA.import_key(open(fileName+"pub.pem").read())

    # This static method is a wraper around the SHA256.
    #   data: input message (string)
    #   return: SHA256 hash of the data
    @staticmethod
    def create_hashobject(data):  
        return SHA256.new(data=json.dumps(data).encode()) # HAcK: (str->binary)->hash
        # print: hashobject.hexdigest()

    # Create a signature for a message
    #   data: input message
    #   return: using our own private key sign the data's hash 
    def create_signature(self, data):
        return pkcs1_15.new(self.priKeyRSA).sign(ITKoin.create_hashobject(data))

    # Verify the signature of a message, using the other party's public key
    #   data: the message
    #   signature: the message's signature
    #   pubKeyRSA: the other party's public key
    #   return: True if the siggnature is correct, False othervise
    def verify_signature(self, data, signature, pubKeyRSA):
        try:
          pkcs1_15.new(pubKeyRSA).verify(ITKoin.create_hashobject(data), signature)
        except ValueError:
          return False
        else:
          return True

# Create an instance
fileName = "ITC"
verrySecureHardcodedPassphrase = "$d8sa9@&=(III)ns83"
myCoin = ITKoin(fileName,passphrase=verrySecureHardcodedPassphrase,generateKey=True)

# Test of what we have so far
def tests(myCoin):
  #signature test
  message = "The quick brown fox jumps over the lazy dog"
  assert(myCoin.verify_signature(message,myCoin.create_signature(message),myCoin.pubKeyRSA))
  mA = "LOVE"
  mB = "HATE"
  assert(not myCoin.verify_signature(mA,myCoin.create_signature(mB),myCoin.pubKeyRSA))

  print("Tests passed!")
  
tests(myCoin)